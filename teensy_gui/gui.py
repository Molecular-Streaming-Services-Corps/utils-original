#!/usr/bin/python


# try:
#     from PIL import ImageGrab  # For Windows & OSx
# except:
#     import pyscreenshot as ImageGrab # For Linux

import os
import re
import sys
import time
import tkinter as tk
from threading import Event
from datetime import datetime, timedelta
import command_line_user_interface as TeaBiscuits


class App(tk.Tk):
    np_default = 'Num Pulses: {}'
    integral_default = 'Integral: {}'
    take_screenshots = False
    def __init__(self, title):
        tk.Tk.__init__(self)
        self.data = []
        self.data_frame = tk.Frame(self, bg="#dfdfdf")
        self.Line1 = None
        self.stop_event = Event()
        self.results_q = None
        self.wm_title(title)
        self.minsize(200, 200) 

        self.wm_geometry("1024x480")
        self.canvas = tk.Canvas(self.data_frame, background="white")
        self.canvas.bind("<Configure>", self.on_resize)
        self.canvas.create_line((0, 0, 0, 0), tag='X', fill='darkblue', width=1)
        self.canvas.create_line((0, 0, 0, 0), tag='Y', fill='darkred', width=1)
        self.canvas.create_line((0, 0, 0, 0), tag='Z', fill='darkgreen', width=1)
        self.canvas.pack(side="top", expand=True, fill='both')

        self.data_frame.pack(side="top", fill="both", expand=True)
        self.config_frame = tk.Frame(self, bg="#dfdfdf")
        

        #self.grid_rowconfigure(0, weight=1)
        #self.grid_columnconfigure(0, weight=1)
        for col_i in range(9):
            #skip allowing resizing on the checkbox and IP address labels
            if col_i in [0, 4,6]:
                continue
            self.config_frame.grid_columnconfigure(col_i, weight=1)
        self.start_b = tk.Button(self.config_frame, text="start stream", width=10, command=self.start_stream)
        self.start_b.grid(row=1,column=0)
        self.stop_b = tk.Button(self.config_frame, text="stop stream", width=10, command=self.stop_stream)
        self.stop_b.grid(row=2,column=0)
        self.stop_b['state'] = tk.DISABLED
        #self.np = tk.StringVar(); self.np.set(self.np_default.format("None Yet"))
        #self.integral = tk.StringVar(); self.integral.set(self.integral_default.format("None Yet"))
        #tk.Label(self, textvariable=self.np).grid(row=2, column=1, sticky="w")
        #tk.Label(self, textvariable=self.integral).grid(row=2, column=3, sticky="w")

        tk.Label(self.config_frame, text="Sample Rate (kHz)").grid(row=1, column=1, sticky='w')
        self.sample_rate = tk.Entry(self.config_frame)
        self.sample_rate.grid(row=2, column=1,sticky="w")
        self.sample_rate.insert(0, '100')

    
        tk.Label(self.config_frame, text="# Samples on Screen").grid(row=1, column=2, sticky='w')
        self.buflen = tk.Entry(self.config_frame)
        self.buflen.grid(row=2, column=2,sticky="w")
        self.buflen.insert(0, '512')
        self.buflen.bind("<Return>", self.update_buflen)
        self.buflen.bind("<FocusOut>", self.update_buflen)
        self.update_buflen(skip_redraw=True)

        tk.Label(self.config_frame, text="Bias Voltage (mV)").grid(row=1, column=3, sticky='w')
        self.voltage_clamp_val = tk.Entry(self.config_frame)
        self.voltage_clamp_val.grid(row=2, column=3, sticky='w')
        self.voltage_clamp_val.insert(0,'100')

        self.use_fake_data = tk.IntVar()
        self.use_fake_data_checkbox = tk.Checkbutton(self.config_frame, text="Use Fake Data", variable=self.use_fake_data)
        # self.use_fake_data_checkbox.grid(row=1, column=4)

        self.use_raw_protocol = tk.IntVar()
        self.use_raw_protocol.set(0)
        self.use_raw_protocol_checkbox = tk.Checkbutton(self.config_frame, text="Use Raw Protocol", variable=self.use_raw_protocol)
        self.use_raw_protocol_checkbox.grid(row=1, column=4, sticky='w')

        self.save_to_disk = tk.IntVar()
        self.save_to_disk_checkbox = tk.Checkbutton(self.config_frame, text="Save To Disk", variable=self.save_to_disk)
        self.save_to_disk_checkbox.grid(row=2, column=4, sticky='w')

        self.save_filename = tk.Entry(self.config_frame, bg='white', fg='grey')
        self.save_filename.grid(row=2, column=5, sticky='we')
        self.save_filename_default_text = "leave empty for autogenerated timestamped file"
        self.save_filename.insert(0, self.save_filename_default_text)
        self.save_filename.bind("<FocusIn>", self.handle_focus_in)
        self.save_filename.bind("<FocusOut>", self.handle_focus_out)
        # self.save_filename.bind("<Return>", handle_enter)

        tk.Label(self.config_frame, text="IP address").grid(row=1, column=6, sticky='e')
        self.host_ip = tk.Entry(self.config_frame)
        self.host_ip.insert(0, 'demonpore.local')
        self.host_ip.grid(row=1, column=7, sticky='w')
        tk.Label(self.config_frame, text="IP port").grid(row=2, column=6, sticky='e')
        self.host_port = tk.Entry(self.config_frame)
        self.host_port.insert(0, '31416')
        self.host_port.grid(row=2, column=7, sticky='w')
        

        tk.Label(self.config_frame, text="Vertical Scaling\n(1.0 is 100%)").grid(row=1, column=8, sticky='w')
        # self.vertical_scaling = tk.Entry(self.config_frame)
        self.vertical_scaling = tk.Spinbox(self.config_frame, from_=0, to=100, increment=0.01,
                                           command=self.replot_labels)
        self.vertical_scaling.delete(0,"end")
        self.vertical_scaling.insert(0,1)
        self.vertical_scaling.grid(row=2, column=8,sticky="w")
        self.vertical_scaling.bind("<KeyRelease>", self.replot_labels)
        # self.vertical_scaling.insert(0,'512')

        tk.Label(self.config_frame, text="Vertical Offset").grid(row=1, column=9, sticky='w')
        self.vertical_offset = tk.Spinbox(self.config_frame, from_=-32768, to=32768, increment=1,
                                          command=self.replot_labels)
        self.vertical_offset.delete(0,"end")
        self.vertical_offset.insert(0,0)
        self.vertical_offset.grid(row=2, column=9,sticky="w")
        self.vertical_offset.bind("<KeyRelease>", self.replot_labels)
        # self.vertical_offset.bind("<Return>", self.refresh_with_larger_screen_buffer)

        self.show_labels = tk.IntVar()
        self.show_labels.set(1)
        self.show_labels.checkbox = tk.Checkbutton(self.config_frame, text="Show labels",
                                                   variable=self.show_labels,
                                                   command=self.show_hide_labels)
        self.show_labels.checkbox.grid(row=1, column=10)

        self.config_frame.pack(side="top", fill="x")#, expand=True)


    def handle_focus_in(self, _):
        self.save_filename.delete(0, tk.END)
        self.save_filename.config(fg='black')

    def handle_focus_out(self, _):
        if self.save_filename.get() == '':
            self.save_filename.delete(0, tk.END)
            self.save_filename.config(fg='grey')
            self.save_filename.insert(0, self.save_filename_default_text)
        
    def update_buflen(self, event=None, skip_redraw=False):
        self.npoints = int(self.buflen.get())
        TeaBiscuits.screen_display_buf_len = self.npoints
        if not skip_redraw:
            self.replot_labels()
        

    # @property
    # def npoints(self):
    #     return self.

    def start_stream(self):
        self.stop_b['state'] = tk.NORMAL
        self.start_b['state'] = tk.DISABLED
        # self.stop_stream()
        self.Line1 = [0 for x in range(self.npoints)]
        save_filename = None
        if self.save_to_disk.get():
            save_filename = self.save_filename.get()
            if save_filename == self.save_filename_default_text:
                save_filename = ''
        self.results_q, self.q_lock, self.stop_event = TeaBiscuits.threaded_stream(HOST=self.host_ip.get(),
                                                                      PORT=int(self.host_port.get()),
                                                                      screen_display_buffer_len=self.npoints,
                                                                      sample_rate_hz=float(self.sample_rate.get())*1000,
                                                                      # screen_refresh_rate=30,
                                                                      save_filename=save_filename,
                                                                      use_fake_data=self.use_fake_data.get(),
                                                                      use_raw_protocol=self.use_raw_protocol.get())
        print('\nstart stream ID\n',id(self.stop_event))
        self.start_plotting()

    def stop_stream(self):
        self.stop_event.set()
        while self.results_q and self.results_q.qsize():
            #print('emptying results_q')
            self.results_q.get()
        self.stop_b['state'] = tk.DISABLED
        self.start_b['state'] = tk.NORMAL
    
    def get_scaling(self):
        x,y,x1,y1 = self.get_widget_bounding_box(self.canvas)
        h = abs(y1-y)
        w = abs(x1-x)
        try:
            vertical_scaling = float(self.vertical_scaling.get())
        except:
            vertical_scaling = 1
        h_scaling = ((h) / ((2**16))) * vertical_scaling

        try:
            vertical_offset = int(self.vertical_offset.get())
        except:
            vertical_offset = 0
        return h, w, h_scaling, vertical_offset

    # zero_time = timedelta(microseconds=0)
    def start_plotting(self):
        #print('GUI start_plotting')
        if not self.stop_event.is_set():
            data = []
            for n in range(0, self.npoints):
                if self.stop_event.is_set():
                    return
                if self.q_lock.locked():
                    if n!=0:
                        print('q-locked (ethernet thread is adding samples '
                              'to the buffer) but currently drawing point '
                              f'#({n}) which should be 0 if the other side '
                              'is adding samples!')
                    self.after(100, self.start_plotting)
                    return
                sample_num, value = self.results_q.get(block=True)                
                data.append(value)
                #print('got val')
            # print('got frame')
            self.data = data
            self.replot()
            self.after(100, self.start_plotting)
    
    def replot(self):
        """
        Update the canvas graph lines from the cached data list.
        The lines are scaled to match the canvas size as the window may
        be resized by the user.
        """
        h, w, h_scaling, vertical_offset = self.get_scaling()
        coordsX = []
        if self.npoints != len(self.data):
            print(f'WARNING: npoints {self.npoints} != len(data) {len(self.data)}')
        for n, value in enumerate(self.data):# in range(0, self.npoints):
            value = self.data[n]
            x = int((w / self.npoints) * n)
            coordsX.append(x)
            y = (int((value+vertical_offset) * h_scaling) + h//2)
            #print(value, y, h_scaling, h)
            coordsX.append(y)
        self.canvas.coords('X', *coordsX)
        
    def on_resize(self, event=None):
        self.replot_labels()
        self.replot()

    def replot_labels(self, event=None):
        if self.show_labels.get():
            h, w, h_scaling, vert_off = self.get_scaling()
            # min_y = (int(-32768 * h_scaling) + h//2) - vert_off
            # max_y = (int(32768 * h_scaling) + h//2) - vert_off
            self.canvas.delete("ticks")
            num_h_ticks = w//50 # 50 pixels minimum distance between on-screen ticks
            num_actual_ticks = self.npoints//num_h_ticks
            num_actual_ticks = num_actual_ticks if num_actual_ticks>1 else 2
            for n in range(0, self.npoints, num_actual_ticks):
                x = int((w / self.npoints) * n)
                self.canvas.create_line(x,0,x,5, width=2, tag='ticks')
                self.canvas.create_text(x,0, text='%d'% (n), anchor=tk.N, tag='ticks')

            print(vert_off)
            vert_tick_dist = h//10
            num_ticks = h//50
            print(f'num_ticks {num_ticks}')
            #for y in range(0, h, h//10):
            vertical_scaling = float(self.vertical_scaling.get())
            lower_range = int((-32768+vert_off)/vertical_scaling)
            upper_range = int((32768+vert_off)/vertical_scaling)
            #tick_inc = int(((2**16)//16) / vertical_scaling)
            tick_inc = int((upper_range-lower_range)//16)
            print(f'h {h}, w {w}, h_scaling {h_scaling} h_scaling*0=={h_scaling*0}, h_scaling*{2**16}=={vertical_scaling*(2**16)}')
            print(f'tick_inc {tick_inc} lower_range {lower_range} upper_range {upper_range}')
            for y in range(lower_range,
                           upper_range, tick_inc):
                scaled_y = (int((y) * h_scaling) + h//2)
                scaled_y_text = (y)#+vert_off) #* vertical_scaling
                print(f'y ({y}) scaled_y ({scaled_y}) scaled_y_text ({scaled_y_text})')
                scaled_y_text = f' {scaled_y_text}'
                self.canvas.create_text(0, scaled_y,
                                        text=scaled_y_text,
                                        anchor=tk.W, tag='ticks')

    def show_hide_labels(self, event=None):
        self.canvas.delete("ticks")
        self.replot_labels()

    # def screenshot(self):
    #     if self.take_screenshots:
    #         pulse_date = datetime.now().strftime('%m_%d_%Y__%H_%M_%S')
    #         ImageGrab.grab(bbox=canvas).save("out_snapsave.jpg")
    #         self.get_widget_bounding_box(self.canvas)
    #         waveform_filename = os.path.join(self.output_directory, 'waveform_{}__{}.png'.format(pulse_date, self.pulse_setting_string))
    #         ImageGrab.grab(bbox=canvas).save(waveform_filename)
    #         #ImageGrab.grab().crop((x,y,x1,y1)).save("file path here")

    def get_widget_bounding_box(self, widget):
        x=widget.winfo_rootx()+widget.winfo_x()
        y=widget.winfo_rooty()+widget.winfo_y()
        x1=x+widget.winfo_width()
        y1=y+widget.winfo_height()
        box=(x,y,x1,y1)
        return box


def main(args = None):
    if args is None:
        args = sys.argv

    if len(args) == 1:
        app = App("Demonpore!")
        app.mainloop()
        return 0
    else:
        print('usage: gui.py')
        return -1


if __name__ == '__main__':
    sys.exit(main())
